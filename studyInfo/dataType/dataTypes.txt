>Numbers
 - important for calcaulations and code where you need to 'work with a number'
 ex) 2, -3, 22.13

>Strings
 - important for outputting results, gathering input
 ex) 'hi', "hi", `hi`

>Booleans
 - important for conditional code and situations where you only have 2 options
 ex) true/false

>Objects
 - important for grouped, related data, helps you with organizing data
 ex) {name: 'Max', age: 31, gender: 'male'}

>Arrays
 - important for list data, unknown amounts of data
 ex) [1,3,5,7]

>Ternary Operator(삼항연산자)
const yourName = isLogin ? 'Yong' : null;
=> isLogin이 true일 때 'yong'으로 yourName에 집어넣는거고
    isLogin이 false일 때 null 값을 받는다.


>!!란?
논리 부정 연산자인 논리 NOT을 두 번 사용한 것
!!를 사용하는 주된 이유: 변수나 표현식의 값을 명시적으로 불리언 타입으로 변환하기 위해. 
어떤 값이 불리언 타입으로 필요한 경우에 !!를 사용하여 간단하게 변환할 수 있음

> &&
 밑에 글과 같이 생성되었을 때 abc가 true이면 a는 'book'이라는 것을 가지게 된다.
    const abc = true;
    let a = abc && 'book';
    console.log(a);

ex2)    const enteredValue = 'Max';
        const userName = enteredValue && 'Anna';
        위에 글에서 userName의 값은? 'Anna'이다.
        이유는 위에 다른 예와 같다.
        첫번째 값인 enteredValue는 'Max'이다.
        이 'Max'라는 값은 String으로 봤을 때 True다.
        그러므로 두번째 값인 'Anna'를 가져오게 된다.
        만약 enteredValue의 값이 false(예를 들면 '', 0, null 등)였다면 userName은 첫번째 값이 userName이 될 것이다.

> ||
 밑에 코드에서 enteredValue가 비어있다면 'PLACEHOLDER'의 값이 된다.
const enteredValue = ''; 
const userName = enteredValue || 'PLACEHOLDER'; 

> Switch Case
 - if는 여러 부등호 >, <, <= 등을 사용할 때 쓰는게 좋지만
    switch case는 ===만 필요할 때 쓰면 훨씬 효율적이다.
 - default는 else와 비슷하게 case에 부합되는 것이 없을 때 발생하는 이벤트다.
switch (a(어떤 값)){
    case A(어떤 값과 비교):
        조건들
        break;
    case B:
        조건들
        break;
    default:

}

위의 값은 밑에 if문과 거의 동일하다.
if(a === A){

} else if(a === B){

} else {

}

//loop
Loop has four kinds of things : for loop, for-of loop, for-in loop, while loop

1. for loop
for(i=0; i<3; i++){
    i is iterator(반복자)
}
-execute code a certain amount of times

2. for-of loop
for(const el of array){
    console.log(el);
}
-Execute for every element in an array
-for-of는 array를 위한 loop

3. for-in loop
for(const key in object){
    console.log(key);
    console.log(object[key]);
}
-execute for every key in an object
-object를 활용하여 만든 loop

4. while loop
while(isLoggedIn){
    ...
}
execute code as long as a condition is true 

>break와 continue로 loop 제어하기
break같은 경우 특정부분에서 아예 loop이 멈춰버린다.
ex) for(let i=0; i<5; i++){
    if(i == 3){
        break;
    }
    console.log(i);
}//결과는 0,1,2
continue는 특정부분을 제외하고 loop이 이어서 돌아간다.
ex) for(let i=0; i<5; i++){
    if(i == 3){
        continue;
    }
    console.log(i);
}//결과는 0,1,2,4



// getElemenyById와 querySelector의 차이점

> querySelector같은 경우에는 특정 id나 class 이름과 함께 이것이 id인지 class인지 정확하게 기입해야한다.
선택자와 일치하는 첫 번째 엘리먼트 객체를 반환합니다.
일치하는 엘리먼트가 없다면 null을 반환합니다.
ex) document.querySelectorAll(".div1");
querySelector와 querySelectorAll의 차이점:
 - querySelector는 아무런 옵션을 붙이지 않는다면 제일 위해 클래스나 아이디에 해당하는 값을 가져온다.
 - querySelector는 배열형식으로 클래스에 해당하는 것들을 가져온다.
file 'querySelectorAndGetById' 참조.

> getElemenyById or getElementByClassName는 
-id명 혹은 class명과 일치하는 엘리먼트 객체를 반환합니다.
-일치하는 엘리먼트가 없다면 null을 반환합니다.
ex) element = document.getElementById(id);

대체로 querySelector는 getElementById에 비해 연산이 느립니다. (약 1.3배)
다만 큰 성능 차이는 아닙니다. querySelector의 초당 연산량은 약 700만 회이기 때문입니다.
또한 querySelector는 getElementByID에 비해 브라우저의 지원 범위가 좁습니다.
그러나 querySelector의 장점은 생산성과 편의성의 측면에서 크게 나타납니다.
id, class, [data-*=""],input[name=""]등 다양한 선택자를 사용할 수 있기 때문입니다.


// attribute와 property의 차이점

> attribute
-attribute 는 html 문서에서 elements 에 추가적인 정보를 넣을 때 사용되는 요소입니다.
ex) <div class= ‘my-class’></div>라는 ‘my-class’라는 클래스 속성을 가진 div 요소에서 
    div 는 element(요소) 이고 
    class 는 attribute(속성) 가 되며 
    ‘my-class’ 는 class attribute의 value(값)가 됩니다.

> property
-property는 html DOM 안에서 attribute 를 가리키는(혹은 대신하는) 표현입니다.

> attribute와 property를 구분하는 차이 또는 차이점이 무엇?
attribute는 html document/file 안에서 property 는 html DOM tree안에서 존재합니다. 
이것이 뜻하는 것은 attribute는 정적으로 변하지 않고 
property는 동적으로 그 값이 변할 수 있다는 것을 내포하고 있습니다. 
ex) 체크박스 태그가 있을 때 유저가 체크박스에 체크를 하면 attribute의 상태는 변하지 않지만 
property의 상태는 checked로 변하게 됩니다.


// innerHTML insertAdjacentHTML 차이점

> innerHTML은 js에서 html에 ??을 추가할 수 있다.
  이때 추가 되었을 때 rerender(새로고침?)이 되어서 작성하던 것들이 사라진다.

> insertAdjacentHTML 또한 기능은 비슷하다.
  하지만 rerender가 되지 않아서 user가 작성하던 것이 사라지지 않는다.
  더 빠르게 반응한다.


  